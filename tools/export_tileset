#! /usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import math
import json
import os
import errno
import numpy as np
import yaml
from psycopg2 import connect, sql
from psycopg2.extras import NamedTupleCursor
from py3dtiles import TriangleSoup, GlTF, B3dm, BatchTable

class BoundingBox():
    def __init__(self, minimum, maximum):
        self.min = [float(i) for i in minimum]
        self.max = [float(i) for i in maximum]

    def inside(self, point):
        return ((self.min[0] <= point[0] < self.max[0])
            and (self.min[1] <= point[1] < self.max[1]))

    def center(self):
        return [(i + j) / 2 for (i,j) in zip(self.min, self.max)]

    def add(self, box):
        self.min = [min(i,j) for (i,j) in zip(self.min, box.min)]
        self.max = [max(i,j) for (i,j) in zip(self.max, box.max)]

class Feature():
    def __init__(self, index, box):
        self.index = index
        self.box = box
        # Used for temporal extension
        self.year_of_construction = None
        self.year_of_demolition = None

class Node():
    counter = 0

    def __init__(self, features = []):
        self.id = Node.counter
        Node.counter += 1
        self.features = features
        self.box = None
        self.children = []
        # Used for temporal extension
        self.start_date = None
        self.end_date = None

    def add(self, node):
        self.children.append(node)

    def compute_bbox(self):
        self.box = BoundingBox([float("inf"), float("inf"), float("inf")],
                          [-float("inf"), -float("inf"), -float("inf")])
        for c in self.children:
            c.compute_bbox()
            self.box.add(c.box)
        for g in self.features:
            self.box.add(g.box)

    def to_tileset(self, transform, temporalExtension=False):
        self.compute_bbox()
        tiles = {
            "asset": {"version" : "1.0", "gltfUpAxis": "Z"},
            "geometricError": 500, # TODO
            "root" : self.to_tileset_r(500, temporalExtension)
        }
        tiles["root"]["transform"] = [round(float(e), 3) for e in transform]
        return tiles

    def to_tileset_r(self, error, temporalExtension=False):
        (c1, c2) = (self.box.min, self.box.max)
        center = [(c1[i] + c2[i]) / 2 for i in range(0,3)]
        xAxis = [c2[0] - c1[0], 0, 0]
        yAxis = [0, c2[1] - c1[1], 0]
        zAxis = [0, 0, c2[2] - c1[2]]
        box = [round(x, 3) for x in center + xAxis + yAxis + zAxis]

        tile = {
            "boundingVolume": {
                "box": box,
            },
            "geometricError": error, # TODO
            "children": [n.to_tileset_r(error / 2., temporalExtension) for n in self.children],
            "refine": "add"
        }

        if temporalExtension:
            tile["boundingVolume"]["start_date"] = self.start_date.isoformat()
            tile["boundingVolume"]["end_date"] = self.end_date.isoformat()

        if len(self.features) != 0:
            tile["content"] = {
                "url": "tiles/{0}.b3dm".format(self.id)
            }

        return tile

    def all_nodes(self):
        nodes = [self]
        for c in self.children:
            nodes.extend(c.all_nodes())
        return nodes

    # Computes the earliest start_date of the node amongst the dates
    # of constructions of its features and the one of its children
    def compute_tree_start_date_r(self):
        # Compute earliest year_of_construction of features of node
        for feature in self.features:
            if self.start_date is None:
                self.start_date = feature.year_of_construction
            else:
                self.start_date=min(self.start_date, feature.year_of_construction)

        # Recurse on children and compute earliest start_date
        for n in self.children:
            n.compute_tree_start_date_r()
            if self.start_date is None:
                self.start_date = n.start_date
            else:
                self.start_date = min(self.start_date, n.start_date)

    # Computes the latest end_date of the node amongst the dates
    # of demolitions of its features and the one of its children
    def compute_tree_end_date_r(self):
        # Compute latest year_of_demoliton of features of node n
        for feature in self.features:
            if self.end_date is None:
                self.end_date = feature.year_of_demolition
            else:
                self.end_date=max(self.end_date, feature.year_of_demolition)

        # Recurse on children and compute latest start_date
        for n in self.children:
            n.compute_tree_end_date_r()
            if self.end_date is None:
                self.end_date = n.end_date
            else:
                self.end_date = min(self.end_date, n.end_date)

def tile_extent(extent, size, i, j):
    minExtent = [extent.min[0] + i*size,
                 extent.min[1] + j*size]
    maxExtent = [extent.min[0] + (i+1)*size,
                 extent.min[1] + (j+1)*size]
    return BoundingBox(minExtent, maxExtent)

# TODO: transform
def arrays2tileset(positions, normals, bboxes, transform, ids, temporalExtension, year_const, year_demol):
    print("Creating tileset...")
    maxTileSize = 2000
    featuresPerTile = 20;
    indices = [i for i in range(len(positions))]
    # Compute extent
    xMin = yMin = float('inf')
    xMax = yMax = - float('inf')

    for bbox in bboxes:
        xMin = min(xMin, bbox[0][0])
        yMin = min(yMin, bbox[0][1])
        xMax = max(xMax, bbox[1][0])
        yMax = max(yMax, bbox[1][1])
    extent = BoundingBox([xMin, yMin], [xMax, yMax])
    extentX = xMax - xMin
    extentY = yMax - yMin

    # Create quadtree
    tree = Node()
    index = {}
    bboxIndex = {}
    for i in range(0, int(math.ceil(extentX / maxTileSize))):
        for j in range(0, int(math.ceil(extentY / maxTileSize))):
            tile = tile_extent(extent, maxTileSize, i, j)

            geoms = []
            for idx, box in zip(indices, bboxes):
                bbox = BoundingBox(box[0], box[1])

                if tile.inside(bbox.center()):
                    geoms.append(Feature(idx, bbox))

            if len(geoms) == 0:
                continue

            if len(geoms) > featuresPerTile:
                node = Node(geoms[0:featuresPerTile])
                tree.add(node)
                divide(tile, geoms[featuresPerTile:len(geoms)], i * 2,
                       j * 2, maxTileSize / 2., featuresPerTile, node)
            else:
                node = Node(geoms)
                tree.add(node)

    # Export b3dm
    print("Creating tiles...")
    nodes = tree.all_nodes()
    identity = np.identity(4).flatten('F')
    try:
        os.makedirs("tiles")
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    for node in nodes:
        if len(node.features) != 0:
            binarrays = []
            gids = []
            if temporalExtension:
                year_const_tile = []
                year_demol_tile = []
            for feature in node.features:
                pos = feature.index
                binarrays.append({
                    'position': positions[pos],
                    'normal': normals[pos],
                    'bbox': [[float(i) for i in j] for j in bboxes[pos]],
                })
                gids.append(ids[pos])
                if temporalExtension:
                    # Convert dates to strings in isoformat and fill lists of dates
                    year_const_tile.append(year_const[pos].isoformat())
                    feature.year_of_construction = year_const[pos]

                    year_demol_tile.append(year_demol[pos].isoformat())
                    feature.year_of_demolition = year_demol[pos]

            gltf = GlTF.from_binary_arrays(binarrays, identity)
            bt = BatchTable()
            bt.add_property_from_array("id", gids)
            if temporalExtension:
                bt.add_property_from_array("year_of_construction", year_const_tile)
                bt.add_property_from_array("year_of_demolition", year_demol_tile)
            b3dm = B3dm.from_glTF(gltf, bt).to_array()
            f = open("tiles/{0}.b3dm".format(node.id), 'wb')
            f.write(b3dm)

    #Â Export Tileset
    if temporalExtension: # Compute temporal interval of existence of tiles
        tree.compute_tree_start_date_r()
        tree.compute_tree_end_date_r()

    tileset = tree.to_tileset(transform, temporalExtension)
    f = open("tileset.json".format(node.id), 'w')
    f.write(json.dumps(tileset))


def divide(extent, geometries, xOffset, yOffset, tileSize,
           featuresPerTile, parent):
    for i in range(0, 2):
        for j in range(0, 2):
            tile = tile_extent(extent, tileSize, i, j)

            geoms = []
            for g in geometries:
                if tile.inside(g.box.center()):
                    geoms.append(g)
            if len(geoms) == 0:
                continue

            if len(geoms) > featuresPerTile:
                node = Node(geoms[0:featuresPerTile])
                parent.add(node)
                divide(tile, geoms[featuresPerTile:len(geoms)],
                       (xOffset + i) * 2, (yOffset + j) * 2,
                       tileSize / 2., featuresPerTile, node)
            else:
                node = Node(geoms)
                parent.add(node)

def wkbs2tileset(wkbs, transform, ids=None, temporalExtension=False, year_const=None, year_demol=None):
    geoms = [TriangleSoup.from_wkb_multipolygon(wkb) for wkb in wkbs]
    positions = [ts.getPositionArray() for ts in geoms]
    normals = [ts.getNormalArray() for ts in geoms]
    bboxes = [ts.getBbox() for ts in geoms]
    arrays2tileset(positions, normals, bboxes, transform, ids, temporalExtension, year_const, year_demol)

def from_db(db_config, temporalExtension):

    # Connect to database
    db = connect(
        "postgresql://{0}:{1}@{2}:{3}/{4}"
        .format(db_config['PG_USER'], db_config['PG_PASSWORD'], db_config['PG_HOST'],
        db_config['PG_PORT'], db_config['PG_NAME']),
        cursor_factory=NamedTupleCursor, # fetch method will return named tuples instead of regular tuples
    )

    cur = db.cursor()

    print("Loading data from database...")
    cur.execute("SELECT ST_3DExtent({0}) FROM {1}".format(db_config['GEOMETRY'], db_config['TABLE']))
    extent = cur.fetchall()[0][0]
    extent = [m.split(" ") for m in extent[6:-1].split(",")]
    offset = [(float(extent[1][0]) + float(extent[0][0])) / 2,
              (float(extent[1][1]) + float(extent[0][1])) / 2,
              (float(extent[1][2]) + float(extent[0][2])) / 2]

    if temporalExtension:
        cur.execute("SELECT ST_AsBinary(ST_Translate({0}, {1}, {2}, {3})),"
                    "St_Area(Box2D({0})) AS weight, {5}, {6}, {7} FROM {4} ORDER BY weight DESC"
                    .format(db_config['GEOMETRY'], -offset[0], -offset[1], -offset[2],
                            db_config['TABLE'], db_config['ID'], db_config['YEAR_OF_CONSTRUCTION'],
                            db_config['YEAR_OF_DEMOLITION']))
    else:
        cur.execute("SELECT ST_AsBinary(ST_Translate({0}, {1}, {2}, {3})),"
                    "ST_Area(ST_Force2D({0})) AS weight, {5} FROM {4} ORDER BY weight DESC"
                    .format(db_config['GEOMETRY'], -offset[0], -offset[1], -offset[2],
                            db_config['TABLE'], db_config['ID']))

    res = cur.fetchall()
    wkbs = [t[0] for t in res]
    ids = [t[2] for t in res]
    year_const = None
    year_demol = None

    if temporalExtension:
        year_const = [t[3] for t in res]
        year_demol = [t[4] for t in res]
        if None in year_const or None in year_demol:
            raise RuntimeError("construction and destruction dates of features "
            "must be filled in the database")
            sys.exit()


    transform = np.array([
        [1, 0, 0, offset[0]],
        [0, 1, 0, offset[1]],
        [0, 0, 1, offset[2]],
        [0, 0, 0, 1]], dtype=float)
    transform = transform.flatten('F')

    wkbs2tileset(wkbs, transform, ids, temporalExtension, year_const, year_demol)

def from_directory(directory, offset):
    # TODO: improvement -> order wkbs by geometry size, similarly to database mode
    offset = (0,0,0) if offset is None else offset
    # open all wkbs from directory
    files = os.listdir(directory)
    files = [os.path.join(directory, f) for f in os.listdir(directory)]
    files = [f for f in files if os.path.isfile(f) and os.path.splitext(f)[1] == '.wkb']
    wkbs = []
    for f in files:
        of = open(f, 'rb')
        wkbs.append(of.read())
        of.close()

    transform = np.array([
        [1, 0, 0, offset[0]],
        [0, 1, 0, offset[1]],
        [0, 0, 1, offset[2]],
        [0, 0, 0, 1]], dtype=float)
    transform = transform.flatten('F')
    wkbs2tileset(wkbs, transform)

if __name__ == '__main__':
    # arg parse
    descr = 'Generate a tileset from a set of geometries'
    parser = argparse.ArgumentParser(description=descr)

    group = parser.add_mutually_exclusive_group()

    d_help = 'name of the directory containing the geometries'
    group.add_argument('-d', metavar='DIRECTORY', type=str, help=d_help)

    o_help = 'offset of the geometries (only with -d)'
    parser.add_argument('-o', nargs=3, metavar=('X', 'Y', 'Z'), type=float, help=o_help)

    D_help = 'database configuration file path'
    group.add_argument('-D', metavar='DATABASE', type=str, help=D_help)

    temporal_help = 'Outputs a temporally extended 3d-tiles file. Only works with -D'
    parser.add_argument('-t', '--temporal', dest='temporal', action='store_true', help=temporal_help)

    args = parser.parse_args()

    if args.D != None: # Database
        # Load yml db configuration file
        db_config = None

        with open(args.D, 'r') as db_config_file:
            try:
                db_config = yaml.load(db_config_file)
                db_config_file.close()
            except:
                print('ERROR: ', sys.exec_info()[0])
                db_config_file.close()
                sys.exit()

        # Check that db configuration is well defined
        if (("PG_HOST" not in db_config) or ("PG_NAME" not in db_config)
            or ("PG_PORT" not in db_config) or ("PG_USER" not in db_config)
            or ("PG_PASSWORD" not in db_config) or ("TABLE" not in db_config)
            or ("ID" not in db_config) or ("GEOMETRY" not in db_config)):
            raise RuntimeError("ERROR: Database is not properly defined in "
            "'{0}', please refer to README.rst".format(args.D))
            sys.exit()

        from_db(db_config, args.temporal)

    elif args.d != None:
        from_directory(args.d, args.o)
    else:
        parser.print_help()
